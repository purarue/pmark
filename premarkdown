#!/usr/bin/env perl

use Getopt::Std qw(getopt);
use File::Spec qw(splitpath rel2abs);
use Cwd qw(cwd);

use strict;
use warnings;

my $cwd = Cwd::cwd();

# accepts and script contents, directory and filepath for markdown file
sub execute_markdown_script($$$) {
  my ($script_contents, $script_dir, $pre_md_fp) = @_;
  # set environment variables
  # write to file
  # make executable
  # run, exit if script returns non-zero exit code
  # return script output (markdown)
  return "beginning" . $script_contents . "end" . "\n\n";
}

sub run_premarkdown($) {
  my ($md_fp) = @_;
  my($vol,$dir,$file) = File::Spec->splitpath(File::Spec->rel2abs($md_fp));
  #print $vol, "\n";
  #print $dir, "\n";
  #print $file, "\n";
  unless ($file =~ m/^PRE_/) {
    print STDERR "$md_fp doesn't start with 'PRE_', ignoring...\n";
    return 1;
  }
  open my $fh, '<', $md_fp or die "error opening $md_fp $!";
  my $file_contents = do { local $/; <$fh> };
  # m: multiline
  # o: compile pattern once
  # g: global - all occurences
  # e: evaluate replacement as an expression
  # r: return subtitution and leave original string untouched
  # (?!```) does negative lookahead to include anything not in a block with ```
  # \s\S+? lazily matches all characters, which is the capture group for the script contents
  my $modified_file_contents = $file_contents =~ s{
    ```\s*\n>>>PREMARKDOWN\s*((?!```)[\s\S]+?)\s*\n```\s*
  }{
    execute_markdown_script($1,$dir,$file)
  }mxogre;
  print $modified_file_contents;
  #print "$file_contents\n";
}

sub parse_args {
  my %flags;
  # keep track of whether or not the user passed something before modifying ARGV with getopts
  my $passed_nothing = scalar(@ARGV) == 0;
  getopt('h', \%flags);
  # if user didnt pass any arguments, or user asked for help...
  if (exists($flags{h}) or $passed_nothing) {
    print "help message\n";
    exit 0;
  }
  return @ARGV;
}

sub main() {
  my @files = parse_args();
  foreach(@files) { run_premarkdown($_); }
}

main()
